# makefile使用知识

Makefile中的命令要求必须是shell支持的，否则会报错。

## 常用语法

### 规则格式

每条规则由如下格式组成，

```
目标…... : 依赖文件集合……
命令 1
命令 2
……
```

### 行首缩进

每行命令行首必须使用tab键缩进，不允许使用空格，因为make会检测tab键作为一条指令，然后使用去执行指令。

### 注释

使用#注释一行。

### 变量

Makefile 中的变量都是字符串，类似 C 语言中的宏，使用变量可以在一定程度上简化makefile的编写。  变量的引用使用“$()”的格式。

```
#Makefile 变量的使用
objects = main.o input.o calcu.o #定义变量objects
main: $(objects) #引用变量objects
	gcc -o main $(objects)
```

### 赋值符 =

使用“=”赋值时，可以将变量的真实值推到后面去定义，也就是变量的真实值取决于它所引用的变量的最后一次有效值 。

### 赋值符 ：=

使用“:=”赋值时，不会使用后面定义的变量，只能使用前面已经定义好的，这就是“=”和“:=”的区别。

### 赋值符 ？=

如果变量 前面没有被赋值，那么此变量就是被赋予新的值，如果前面已经赋过值了，那么就使用前面赋的值 。

### 变量追加 +=

由于Makefile 中的变量是字符串，所以允许在已经定义好的变量后添加一些字符串进去，此时就要使用到符号“+=”  

### 模式规则

模式规则中，至少在规则的目标定定义中要包涵“%”，否则就是一般规则，目标中的“%”表示对文件名的匹配，“%”表示长度任意的非空字符串，比如“%.c”就是所有的以.c 结尾的文件，类似与通配符， a.%.c 就表示以 a.开头，以.c 结束的所有文件。  

### 自动化变量

自动化变量只应该出现在规则的命令中  。

| 自动化变量 | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| $@         | 规则中的目标集合，在模式规则中，如果有多个目标的话，“$@”表示匹配模 式中定义的目标集合。 |
| $%         | 当目标是函数库的时候表示规则中的目标成员名，如果目标不是函数库文件， 那么其值为空。 |
| $<         | 依赖文件集合中的第一个文件，如果依赖文件是以模式(即“%” )定义的，那么 “$<”就是符合模式的一系列的文件集合。 |
| $?         | 所有比目标新的依赖目标集合，以空格分开。                     |
| $^         | 所有依赖文件的集合，使用空格分开，如果在依赖文件中有多个重复的文件， “$^”会去除重复的依赖文件，只保留一份。 |
| $+         | 和“$^”类似，但是当依赖文件存在重复的话不会去除重复的依赖文件。 |
| $*         | 这个变量表示目标模式中"%"及其之前的部分，如果目标是 test/a.test.c，目标模 式为 a.%.c，那么“$*”就是 test/a.test。 |

### 伪指令

使用“.PHONY :”可以将目标声明为伪目标，从而目标下的指令会被正常执行。

## Makefile函数

Makefile 支持函数，类似 C 语言一样， Makefile 中的函数是已经定义好的，我们直接使用，不支持我们自定义函数。函数的使用格式如下：

```
$(函数名 参数集合)
${函数名 参数集合}
```

### dir

此函数用来从文件名序列<names>中提取出目录部分，返回值是文件名序列<names>的目录部分。

```
$(dir </src/a.c>) #提取文件“/src/a.c”的目录部分，也就是“/src”
```

### 